* What is spring-boot-bugger?

Note: Not intended for production, but simplifies paving the way for you to pitch Clojure to your app/organization.

Ever wished to introduce Clojure into your enterprisey SpringBoot app (organization?)
1. But not want to add much noise to your ~build.gradle~ for injecting Clojure
2. Want to start very small - ~nrepl~ and a ring-like sub-module - and then use REPL-power for live-coding and adding new functionality

Then, ~spring-boot-bugger~ simplifies it for you!

* The Pitch: Sample Application Code
** Configure Springboot Application
By default, port 7888 is used. But add /nrepl.port/ to your application.properties (or equivalent) file as follows

#+begin_src yaml
# ...
clojure-component:
  nrepl-port: 8190
  root-path: /internal/clojure
# ...
#+end_src

** Write code
Here is an example code - using Compojure - that you can use in your SpringBoot application!
It works along-side your existing Java code, without interfering, and you can access Clojure from your Java, and vice-versa!
#+begin_src clojure
(ns scratch
  (:require
   [org.msync.spring-boot-bugger :as bugger]
   [compojure.core :refer :all]
   [compojure.route :as route]))

(defroutes app
  (GET "/" [] "<h1>Hello World</h1>")
  (POST "/echo/:greetings" [greetings :as request]
        {:status 200
         :content-type "application/json"
         :body {:greetings greetings :message (:body request)}})
  (route/not-found "<h1>Page not found</h1>"))

(bugger/set-handler! app)
#+end_src

Note that the paths are relative to the base path set in ~application.yml~. Hence, ~/echo/:greetings~ will be accessible at ~/internal/clojure/echo/:greetings~.

* Steps for Gradle
(Modify accordingly for maven)

** Preferred (Clever, but not battle-tested)

Following these steps allow you to enable /NREPL/ by modifying two files in your repository
- build.gradle[.kt]
- .gitignore
The changes are pretty much inconsequential to your core project codebase and should be easy to push through with possibly non-existent pushback.

These steps are *suggestive* and you can tweak - especially the names of files

*** Add the following to your ~.gitignore~
#+begin_example
/dev.gradle**
/**/DevWorx.java
#+end_example

*** Create ~dev.gradle.kt~ (or ~dev.gradle.kt~)
(Or whatever name you'd like - match it with the entry in ~.gitignore~)
#+begin_src kotlin
repositories {
    maven {
        name("Sonatype Snapshots")
        url("https://oss.sonatype.org/content/repositories/snapshots")
        mavenContent {
            snapshotsOnly()
        }
    }
}

dependencies {
    developmentOnly("org.msync:spring-boot-bugger:0.2.0-SNAPSHOT")
    developmentOnly("compojure:compojure:1.6.2")
}
#+end_src

*** Update ~build.gradle.kts~ (or ~build.gradle~ if using Groovy)
Add the following to your ~build.gradle.kts~ - this allows you to tweak your build-script via an optionally present file.
#+begin_src kotlin
if (File("dev.gradle.kt").isFile) {
    apply("dev.gradle.kt")
}
#+end_src

*** Add a Java file to your codebase
Name this file ~DevWorx.java~ (to match your .gitignore entry), and keep it at an appropriate place - your base package
Assuming your base package is ~com.company.my_application~, the file should be created at *src/main/java/com/company/my_application/DevWorx.java*, unless you are not using standard Java+Gradle locations.
#+begin_src java
package com.company.my_application;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

@Component
@Profile("dev")
@ComponentScan("org.msync.spring_boot_bugger")
public class DevWorx {
}
#+end_src

* Run "bootRun"
#+begin_src bash
./gradlew bootRun --args='--spring.profiles.active=dev'
#+end_src

And you should see something like the following
#+BEGIN_QUOTE
...
[2021-09-01 21:47:31,121] INFO  [restartedMain] org.msync.spring_boot_bugger.ClojureConfiguration::startNrepl [spring-boot-bugger] NREPL server started on port 8190
Initializing ClojureComponent...
...
#+END_QUOTE

* Connect to the NREPL
And hack away to glory!

For your convenience, there's a namespace you can switch to and get hold of the ~ApplicationContext~ object via the /state/ atom's ~:ctx~ key.

#+begin_src clojure
user> @org.msync.spring-boot-bugger.application-context/state
;; =>
{:ctx #object[org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext
              0x333bd779
              "org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@333bd779, started on Wed Sep 01 21:47:28 IST 2021"]}
#+end_src

* Control the NREPL service via an end-point

Pretty crude controls. Modify host, port and the path-prefix depending on how you've configured it in your ~application.yml~.

*** Start it
#+begin_src bash
curl http://host:port/internal/clojure/nrepl-start
#+end_src

*** Stop it
#+begin_src bash
curl http://host:port/internal/clojure/nrepl-stop
#+end_src

* Caveats
This is intended (currently) as a purely development-aiding dependency. It's tied to SpringBoot, but can be easily modified for other frameworks like Quarkus.

* License

Copyright Â© 2020-21 - Ravindra R. Jaju

This program and the accompanying materials are made available under the
terms of the Eclipse Public License 2.0 which is available at
[[http://www.eclipse.org/legal/epl-2.0][http://www.eclipse.org/legal/epl-2.0]].

This Source Code may also be made available under the following Secondary
Licenses when the conditions for such availability set forth in the Eclipse
Public License, v. 2.0 are satisfied: GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or (at your
option) any later version, with the GNU Classpath Exception which is available
at [[https://www.gnu.org/software/classpath/license.html][https://www.gnu.org/software/classpath/license.html]].
